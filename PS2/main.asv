%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 
% Benjamin Fry (bfry2)
% 2/14/21, coded on MATLAB _R2020b_ 
% 
%Problem Set 2 - Modeling The Living Cell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 1. Random Number Generation and Seeding

rng('shuffle')

%a. Adjust random normal distribution to mean of 5 and std.dev 2
r = 5 + 2.*randn(1000, 1);

%b. Plot histogram of Counts
figure(1)
histogram(r,35)
title('Frequency Plot For 1000 Points Sampled From N(5,4) Distribution');
ylabel('Number of Values Observed');
xlabel('Value Observed');

%c. Plot histogram of counts as normalized pdf.
figure(2)
histogram(r,35, 'Normalization', 'pdf')
title('PDF of 1000 Points Sampled From N(5,4) Distribution');
ylabel('Probability of Value Observed');
xlabel('Value Observed');
[N, edges] =  histcounts(r,35, 'Normalization', 'pdf');

%check that output of binning sums to 1 when multiplied by edge size.
binsize = edges(2) - edges(1);
disp("Normalized Sum :")
disp(sum(N) * binsize)

%% 2. Sampling From A Discrete Distribution

%Key
aa_key = ['A', 'R', 'N', 'D', 'C', 'Q', 'E', 'G', 'H', 'I', 'L', 'K', ...
    'M', 'F', 'P', 'S', 'T', 'W', 'Y', 'V'];

%Generate a 300 by 1 matrix of random integers on interval [1, 20]
num_seq = randi(20, 300, 1);
figure(1)
histogram(num_seq, 'Normalization', 'pdf')
set(gca,'xtick',[1:20],'xticklabel',aa_key(1:20)');
equal_freq_char_seq = aa_key(num_seq)
title("Residue Frequency in Randomly Generated 300 Residue String Assuming All Have Equal Liklihood")
xlabel("Amino Acid (One Letter Code)")
ylabel("Residue Frequncy (count/string length)")

%True Frequencies
true_freqs = [8.25, 5.53, 4.06, 5.45, 1.37, 3.93, 6.75, 7.07, 2.27, 5.96, ...
    9.66, 5.84, 2.42, 3.86, 4.70, 6.56, 5.34, 1.08, 2.92, 6.87] ./ 100;
sum(true_freqs);

%Calculate Cumulative Sum and plot CDF
cumul = cumsum(true_freqs);
figure(2)
h = stairs(1:20, cumul);
set(gca,'xtick',[1:20],'xticklabel',aa_key(1:20)');
title("Cumulative Distribution Function For Amino Acid Probabilities")
xlabel("Amino Acid (One Letter Code)")
ylabel("Probability")

%Generate 300 random numbers and use CDF to convert to residues
rand300 = rand(300,1);
result = zeros(1,length(rand300));
for i = 1:length(rand300)
    result(i) = getRes(rand300(i), true_freqs);
end
emperical_freq_char_seq = aa_key(result)

figure(3)
histogram(result, 'Normalization', 'pdf');
[model_freqs, edges] = histcounts(result, 'Normalization', 'pdf');
set(gca,'xtick',1:20,'xticklabel',aa_key(1:20)');
title("Residue Frequency in Randomly Generated 300 Residue String Using Expasy Residue Frequencies")
ylabel("Residue Frequncy (count/string length)")
xlabel("Amino Acid (One Letter Code)")


%% 3. Monte Carlo Sampling of Lennard-Jones Particles.

%Load in Data
load('init_crds_boxl_3.5.dat')

%Initialize Variables
L = 3.5; %Length of box
epsilon = 0.25;
sigma = 1;
delta = 0.5;
beta = 1/.1;
disp(beta)

%Loop through points avoiding self and repeat interactions and sum calculated potential
V = 0;
for i = 1:30
    ri = [init_crds_boxl_3_5(i, 1), init_crds_boxl_3_5(i, 2), init_crds_boxl_3_5(i, 3)];
    for j = i+1:30
        rj = [init_crds_boxl_3_5(j, 1), init_crds_boxl_3_5(j, 2), init_crds_boxl_3_5(j, 3)];
        
        v = calc_LJ_Potential(L, epsilon, sigma, ri, rj);
        V = V + v;
    end
end
fprintf("Lennard-Jones Potential With Periodic Boundary Conditions: %.4f\n", V)


%Markov Chain Monte Carlo

num_cycles = 100000;

calculated_energies = zeros(1,num_cycles);
for i = 1:num_cycles
    
    %select a random particle
    selection = randi([1,30]);
    old = [init_crds_boxl_3_5(selection, 1) init_crds_boxl_3_5(selection, 2) init_crds_boxl_3_5(selection, 3)];
    
    %calculate energy of old state
    old_energy = 0;
    for j = 1:30
        if j ~= selection
            old_energy = old_energy + calc_LJ_Potential(L, epsilon, sigma, old, [init_crds_boxl_3_5(j,1) init_crds_boxl_3_5(j,2) init_crds_boxl_3_5(j,3)]);
        end
    end
    
    %Randomly independently adjust x, y, z coordinates of old
    new = zeros(1,3);
    new(1) = old(1) + delta*(rand()-0.5);
    new(2) = old(2) + delta*(rand()-0.5);
    new(3) = old(3) + delta*(rand()-0.5);
    
    %Calculate energy of new state
    new_energy = 0;
    for j = 1:30
        if j ~= selection
            new_energy = new_energy + calc_LJ_Potential(L, epsilon, sigma, new, [init_crds_boxl_3_5(j,1) init_crds_boxl_3_5(j,2) init_crds_boxl_3_5(j,3)]);
        end
    end
    
    %Define acceptance criterion with Boltzmann factor.
    acc = min([1, exp(-beta * (new_energy - old_energy))]);
    
    %If a randomly generated number is less than the acceptance criterion, we accept the old to new transition
    if rand() < acc
        %Update old in data matrix with new value
        init_crds_boxl_3_5(selection, 1) = new(1); %#ok<SAGROW>
        init_crds_boxl_3_5(selection, 2) = new(2); %#ok<SAGROW>
        init_crds_boxl_3_5(selection, 3) = new(3); %#ok<SAGROW>
        
        %Append the calculated energy of the new state to energy array for calculation of average
        calculated_energies(i) = new_energy;
    else
        %If we do not accept the transition, we keep the old energy and append to energy array for average calculation
        calculated_energies(i) = old_energy;
    end
end

average_V = sum(calculated_energies)/num_cycles;
fprintf("Calculated Average Potential Energy of: %.4f", average_V)


